<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
  "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Vim Control Sequence Example</title>
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<body>

<h1>Vim Control Sequence Examples</h1>
<p>
When a user uses the control sequence, the remote host can control the Tera Term behavior.
The Vim procedure for using the control sequence is described below.
</p>

<h2><a name="CursorStyle">Changing cursor shape on entering and leaving into insert mode</a></h2>
<p>
Tera Term can support below control sequence changing the cursor shape.
</p>

<table border="1">
  <tr> <th>Abbreviation</th> <th>Sequence</th> <th>Function</th> </tr>

  <tr> <td rowspan="2">DECTCEM</td>
       <td>ESC [ ? 25 h</td> <td>Makes the cursor visible</td> </tr>
  <tr> <td>ESC [ ? 25 l</td> <td>Makes the cursor invisible</td> </tr>

  <tr> <td rowspan="7">DECSCUSR</td>
       <td>ESC SP 0 q</td> <td>Blink Block</td> </tr>
  <tr> <td>ESC SP 1 q</td> <td>Blink Block</td> </tr>
  <tr> <td>ESC SP 2 q</td> <td>Steady Block</td> </tr>
  <tr> <td>ESC SP 3 q</td> <td>Blink Underline</td> </tr>
  <tr> <td>ESC SP 4 q</td> <td>Steady Underline</td> </tr>
  <tr> <td>ESC SP 5 q</td> <td>Blink Vertical line</td> </tr>
  <tr> <td>ESC SP 6 q</td> <td>Steady Vertical line</td> </tr>

  <tr> <td rowspan="2">WYSTCURM</td>
       <td>ESC [ 33 h</td> <td>Steady Wyse Cursor</td> </tr>
  <tr> <td>ESC [ 33 l</td> <td>Blink Wyse Cursor</td> </tr>

  <tr> <td rowspan="2">WYULCURM</td>
       <td>ESC [ 34 h</td> <td>Steady Wyse underline cursor</td> </tr>
  <tr> <td>ESC [ 34 l</td> <td>Steady Wyse block cursor</td> </tr>

  <tr> <td rowspan="2"> (AT&amp;T 610) </td>
       <td>ESC [ ? 12 l</td> <td>Steady Cursor</td> </tr>
  <tr> <td>ESC [ ? 12 h</td> <td>Blink Cursor</td> </tr>
</table>

<p>
The vim cursor can be changed in the insert mode to output above control sequences when a user enters(t_SI) and leaves(t_EI). <br>
For example, when below contents is added in the .vimrc file, the cursor style is underline and blinking in the insert mode. Next, the cursor style is block and blinking outside the insert mode.
</p>

<pre class="macro-example">
let &amp;t_SI .= "\e[3 q"
let &amp;t_EI .= "\e[1 q"
</pre>

<p>NOTICE: If a user uses the control sequence except the DECTCEM, turn on the Cursor control sequence of the Additional Settings dialog(The default value is off).</p>


<h2><a name="Bracketed">Auto indent can be disabled on pasting from clipboard</a></h2>
<p>
Basically, the host application can not recognize the difference between the user input and pasting from clipboard.
However, when a user uses the Bracketed Paste Mode as the xterm extension, the application can recognize its difference and a user can change the behavior of pasting from clipboard.
</p>

<p>
The vim configuration is described below. The following will use xterm's bracketed paste mode to make pasting automatically enable paste mode and insert mode. Also works fine in ~/.vimrc file.
</p>

<pre class="macro-example">
if &amp;term =~ "xterm"
    let &amp;t_ti .= "\e[?2004h"
    let &amp;t_te .= "\e[?2004l"
    let &amp;pastetoggle = "\e[201~"

    function XTermPasteBegin(ret)
        set paste
        return a:ret
    endfunction

    noremap &lt;special&gt; &lt;expr&gt; &lt;Esc&gt;[200~ XTermPasteBegin("0i")
    inoremap &lt;special&gt; &lt;expr&gt; &lt;Esc&gt;[200~ XTermPasteBegin("")
    cnoremap &lt;special&gt; &lt;Esc&gt;[200~ &lt;nop&gt;
    cnoremap &lt;special&gt; &lt;Esc&gt;[201~ &lt;nop&gt;
endif
</pre>

<p>
When a user pastes at the normal mode by using the above configuration, the mode will be automatically changed to the insert mode and do the paste. If this behavior is denied, use the below configuration.<br>
Also, refer to the <a href="#withScreen">GNU Screen Notice</a>.
</p>

<pre class="macro-example">
if &amp;term =~ "xterm"
    let &amp;t_SI .= "\e[?2004h"
    let &amp;t_EI .= "\e[?2004l"
    let &amp;pastetoggle = "\e[201~"

    function XTermPasteBegin(ret)
        set paste
        return a:ret
    endfunction

    inoremap &lt;special&gt; &lt;expr&gt; &lt;Esc&gt;[200~ XTermPasteBegin("")
endif
</pre>

<h4>About Bracketed Paste mode</h4>
<p>
The bracketed paste mode is the xterm extension feature. When this feature is enabled, the pasted text is bracketed with control sequences so that the program can differentiate the pasted text from typed-in text.<br>
The program will receive: ESC [ 200 ~, followed by the pasted text, followed by ESC [ 201 ~.
</p>


<h2><a name="IMEcontrol">Controlling IME</a></h2>
<p>
Tera Term can support the original sequence to control the IME behavior.
For example, A user can switch the IME status of enabling and disabling to use this control sequence.
</p>

<p>
When below contents is be added in the .vimrc file, the IME status is off after the insert mode exiting. Next, the IME status is on after the insert mode enabling.
</p>

<pre class="macro-example">
let &t_SI .= "\e[&lt;r"
let &t_EI .= "\e[&lt;s\e[&lt;0t"
let &t_te .= "\e[&lt;0t\e[&lt;s"

set timeoutlen=100
</pre>

<p>
When the timeoutlen of the vim is enabled, the vim will wait until either the complete mapping or key sequence has been received. In other words, the timeoutlen is used to describe the time from IME on to off after the ESC key is pressed in the insert mode. <br>
If the timeoutlen is the small value, a trouble may occur that the cursor and function key do not work well. <br>
As an alternative, please use the <a href="#AppESC">Delete wait time after ESC key is pushed in insert mode</a>.
</p>


<h2><a name="AppESC">Delete wait time after ESC key is pushed in insert mode</a></h2>
<p>
When the ESC key is pressed, Tera Term, xterm and other terminal emulator send the ESC(0x1b) key code. Also, when the cursor key and the function key is pushed, Tera Term sends the ESC key code.
Therefore, the host application can not recognize whether the ESC key is pressed. <br>
So, the vim waits for one second when the ESC key code is received to recognize what key is pressed.
As a result, when a user presses the ESC key, the time for the insert mode exiting will be late for 1 second.
This behavior can not be affected by enabling <a href="#CursorStyle">Changing cursor shape on entering and leaving into insert mode</a> and <a href="#IMEcontrol">Controlling IME</a>.
</p>

<p>
Please use the Application Wheel Mode to resolve this problem.
When below contents is added in the .vimrc file, the insert mode is quickly exited after the ESC key is pressed.
</p>

<pre class="macro-example">
let &t_SI .= "\e[?7727h"
let &t_EI .= "\e[?7727l"
inoremap &lt;special&gt; &lt;Esc&gt;O[ &lt;Esc&gt;
</pre>


<h2><a name="withScreen">GNU Screen Notice</a></h2>
<p>
When the GNU Screen is used, an application on the screen sends the control sequence and the sequence will be abandoned because the screen can not support the sequence.
</p>

<pre class="macro-example">
if &amp;term == "screen"
    let &amp;t_SI .= "\eP\e[3 q\e\\"
    let &amp;t_EI .= "\eP\e[1 q\e\\"
else
    let &amp;t_SI .= "\e[3 q"
    let &amp;t_EI .= "\e[1 q"
endif
</pre>

<p>
Use the above configuration to resolve this problem. When the terminal type is `screen', the vim entry sandwitches in the sequence between the "\eP" and "\e\\".<br>
However, the screen can not work to switch the window because the sequence can not be managed by the screen.
</p>

</body>
</html>
