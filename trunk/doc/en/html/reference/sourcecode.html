<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
  "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>Tera Term Source Code Overview</TITLE>
<META http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" href="../style.css" type="text/css">
</HEAD>
<BODY>

<h1 class="center">Tera Term Source Code Overview</h1>

<hr width=80% align=center>

<ol>
  <li><a href="#foreword">Foreword</a></li>
  <li><a href="#skillset">Required Skill Sets</a></li>
  <li><a href="#module">Tera Term Package Content</a></li>
  <li><a href="#library">Third Party Libraries</a></li>
  <li><a href="#plugin">Plug-in Support</a></li>
  <li><a href="#configuration">Reading and Writing Configuration File</a></li>
  <li><a href="#secure">Secure Programming</a></li>
  <li><a href="#compatibility">Compatibility with Obsolete Windows Versions</a></li>
  <li><a href="#debug">Debugging Methods</a></li>
  <li><a href="#thread">Multithreading</a></li>
  <li><a href="#dde">DDE Communication</a></li>
  <li><a href="#ttssh">SSH Design and Implementation in TTSSH</a></li>
  <li><a href="#macro">Macro Language Design and Implementation</a></li>
  <li><a href="#caret">Caret Control</a></li>
  <li><a href="#serial">Serial Port</a></li>
  <li><a href="#xyzmodem">Binary Transfer Protocols</a></li>
</ol>

<hr width=80% align=center>

 This article was written by TeraTerm Project in February 2008. The original is in Japanese language and is available from <a class="lnk" onclick="window.open(this.href); return false;" href="http://ttssh2.osdn.jp/manual/ja/reference/sourcecode.html">ttssh2.osdn.jp</a>. Yutaka Hirata and Boris Maisuradze translated the article to English in December 2015.</p> 
    
    
<h2><a name="foreword">Foreword</a></h2>
    This article describes the source code of Tera Term version 4.58 released in February 2008. The general architecture of Tera Term did not change since then, so this description can be considered as up-to-date.     
<hr>


<h2><a name="skillset">Required Skill Sets</a></h2>
    Most program included in the Tera Term package are described with the C language.
    A part of code is described with the C++ language and used by MFC(Microsoft Foundation Class).
    The Win32 API knowledge is required because the source code uses a lot of Win32 API to process the Windows specific function. <br>
    The Microsoft Visual Studio 2005 Standard Edition or later is required to build the source code. Unfortunately, the Express Edition can not build the source code because the Edition can not support the MFC feature. Also, Other compilers like the C++Builder, Turbo C++ Explorer and gcc can not be supported. <br>
    The Windows programming know-how is at the MSDN library provided by Microsoft Corporation.
    A user will often refer the MSDN library while the user is developing the software. <br>

<ul>
  <li><a href="http://msdn2.microsoft.com/en-us/library/default.aspx">MSDN library</a></li>
  <li><a href="http://msdn2.microsoft.com/ja-jp/library/default.aspx">MSDN library(Japanese)</a></li>
</ul>

<p>
    However, the CygTerm is built with the gcc compiler of the Cygwin package. So, the CygTerm program is implemented by using the gcc feature. The source code is the C language.
</p>

    The main engine of Tera Term is implemented by using the C++ language. It is no problem that your programming skill is only C language because the code is C-like programming. However, the Microsoft Visual C++(VC++) supports the ANSI C standard(C89) and not support the C99 version. The C99-like feature is uniquely supported by VC++. The C99-like function adds the underscore(_) to the initial name of function in order to distinguish easily. For example, the _snprintf() of VC++ is different from the snprintf() of ANSI C(C99). <br>

<hr>


<h2><a name="module">Tera Term Package Content</a></h2>
    Tera Term contains many executable module(.exe and .dll) and the association figure are below shown. An extension of an executable file is ".exe" and any DLL files are dynamically linked as needed.  Every module is the 32-bit program(x86) and the developer team will not validate the Tera Term software on the 64-bit environment like the x86-64 and IA-64. 
  
<div align="center">
<img src="image/module_relation.png" width=720 height=540>
</div>
    
    Basically, when a user launches the Tera Term from the Desktop and Start Menu, the "ttermpro.exe" file is executed at first. Additionally, the executable file calls five DLL files by the dynamic link. The "ttermpro.exe" file is not an all-in-one file by using the static link because the memory consumption of one process suppresses. Is is assumed that a number of Tera Term starts, and the Tera Term is divided to any DLL files from the initial design of a program. A DLL file is shared among a number of process after the DLL file is loaded into the system memory. <br>
  <br>
    
    When a macro script is called, another "ttpmacro.exe" program is launched. A macro script can be executed by myself because the Tera Term divides into the "ttermpro.exe" and the "ttpmacro.exe" program. So, the process communication mechanism is needed for two processes communication. Tera Term uses the DDE(Dynamic Data Exchange) mechanism which is the legacy system on current Windows. Windows will not support the DDE mechanism in the future, so the macro script will not be able to execute. <br>
  <br>
    
    A plug-in DLL like the TTSSH, TTProxy and TTXKanjiMenu is dynamically loaded by using the LoadLibrary() API on Tera Term startup. A DLL filename is selected by the "TTX*.DLL" pattern matching by the TTXInit()#ttplug.c function. <br>
  <br>
  
    The "keycode.exe", "ttpmenu.exe" and "LogMeTT.exe" are another process.<br>
  <br>
  
    The Cygwin connection mechanism is described at another chapter.

<hr>

<h2><a name="library">Third Party Libraries</a></h2>
    It is not efficiently performed to build a software from scratch for advanced feature. So, Tera Term actively uses the open source library. However, we need to be careful with the license violation,  especially GPL. <br>
    Some modules linked with the open source library and the linkage status are below shown. The macro program links the regular expression library that is called Oniguruma to use the regular expression by the "waitregex" and "sprintf" macro command. Also, Tera Term program links the same library to display the Oniguruma version on the version dialog.
  
<p>
    The "TTSSH" module uses the OpenSSL library to perform the cryptography processing. Is seems that the OpenSSL library has only the SSL(Secure Socket Layer) protocol function for web accessing, however that is wrong. The OpenSSL library supports basic cipher algorithm and the "TTSSH" module uses only basic function. In other words, the "TTSSH" module will not be almost affected when the OpenSSL library has the security hole. <br>
    The zlib library is used to compress the SSH packet. So, the packet compression is effective on lower network throughput like the dial-up connection, however the performance is not good on high-speed network. So, the packet compression function is disable by default. <br>
    The PuTTY is a terminal emulator for free, and defacto standard in world-wide. The Pageant program of the PuTTY package is the SSH authentication agent, and the TTSSH uses the PuTTY source code to support the Pageant authentication method.
</p>
    
    Carefully, every library is the static link not the dynamic link. The compile option of the library is added the "/MT" option. Currently, the dynamic link is not supported because a part of user environment can not launch the Tera Term by using the dynamic link.
  

<div align="center">
<img src="image/library_relation.png" width=720 height=540>
</div>

<hr>
    

<h2><a name="plugin">Plug-in Support</a></h2>
    Tera Term can support the plug-in mechanism by using the DLL module. 
    A user can add new feature without source code modifying when the DLL plug-in module is copied into the Tera Term installation directory. The TTSSH module is typical plug-in module. <br>
    A sample code for plug-in programming is into the TTXSamples\ttxtest\ttxtest.c file. It is recommended that a user develop the plug-in module based on this file. The "TTX KanjiMenu" source code(TTXKanjiMenu\ directory) is practical and simple module. <br><br>

    The plug-in module is loaded on the Tera Term("ttermpro.exe") startup. The TTXInit()#ttplug.c function loads the module. Some DLL files matched the "TTX*.DLL" wild-card character will be loaded.<br>
    When multiple DLL modules are found, an export function of each DLL module is concatenated from Tera Term body. The concatenating order is determined according to the defined order(loadOrder member of TTXExports structure) in the following order:
        
<p>
<table border=1 align=center>
<tr>
  <th>Module</th>
  <th>Order</th>
</tr>

<tr>
  <td>TTProxy</td>
  <td>0</td>
</tr>

<tr>
  <td>TTSSH</td>
  <td>2500</td>
</tr>

<tr>
  <td>TTX Kanji Menu</td>
  <td>5000</td>
</tr>
</table>
 </p>
    
    The smaller order value is nearer to the Tera Term body. For example, the TTXModifyMenu() is called:

  <ul>
   <li>TTXModifyMenu()#ttplug.c -> TTProxy@TTXModifyMenu() -> TTSSH@TTXModifyMenu() -> TTX Kanji Menu@TTXModifyMenu()</li>
  </ul><br>

    Above function of the DLL module are called in order.
  <br>
    
    The export function called by Tera Term body is defined as the TTXExports structure, and the TTXBind() sends the export table to the Tera Term body. For example, the export function of the TTX Kanji Menu plug-in module are as follows:<br>
    Unnecessary function is defined as NULL pointer.

<pre class=code>
static TTXExports Exports = {
/* This must contain the size of the structure. See below for its usage. */
	sizeof(TTXExports),

/* This is the load order number of this DLL. */
	ORDER,

/* Now we just list the functions that we've implemented. */
	TTXInit,
	NULL, /* TTXGetUIHooks */
	NULL, /* TTXGetSetupHooks */
	NULL, /* TTXOpenTCP */
	NULL, /* TTXCloseTCP */
	NULL, /* TTXSetWinSize */
	TTXModifyMenu,
	TTXModifyPopupMenu,
	TTXProcessCommand,
	NULL, /* TTXEnd */
	NULL  /* TTXSetCommandLine */
};
</pre>
    
    Basically, the export function of the plug-in module should be designed not to interfere other plug-in modules. Also, when the plug-in module is called by Tera Term body, the module needs to check the request for own module. <br> 
    Every export function of plug-in module are as follows:

<p>
<table border=1 align=center>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>

<tr>
  <td>TTXBind</td>
  <td>This function is called at first. The function sends the export function table to the Tera Term body.</td>
</tr>

<tr>
  <td>TTXInit</td>
  <td>This function is quickly called after the TTXBind() calling. The function received the global variables(ts and cv) of the Tera Term body, and initialized own plug-in module.</td>
</tr>

<tr>
  <td>TTXGetUIHooks</td>
  <td>This function can hook the dialog handle. The function is used to change the dialog interface of Tera term. The hook target is in the following:<br>
      &SetupTerminal, &SetupWin, &SetupKeyboard, &SetupSerialPort, 
      &SetupTCPIP, &GetHostName, &ChangeDirectory, &AboutDialog,   
      &ChooseFontDlg, &SetupGeneral, &WindowWindow                 
  </td>
</tr>

<tr>
  <td>TTXGetSetupHooks</td>
  <td>This function can hook the setup routine. The hooked function should call the original function. When some plug-in module exists, each function is called in order. The hook target is in the following:<br>
      &ReadIniFile, &WriteIniFile, &ReadKeyboardCnf, &CopyHostList,   
      &AddHostToList, &ParseParam                                     
  </td>
</tr>

<tr>
  <td>TTXOpenTCP</td>
  <td>This function is called on TCP connection, and is not called on Serial connection. Also, the function can hook the socket interface in the following:<br>
      &Pclosesocket, &Pconnect, &Phtonl, &Phtons, &Pinet_addr,   
      &Pioctlsocket, &Precv, &Pselect, &Psend, &Psetsockopt,     
      &Psocket, &PWSAAsyncSelect, &PWSAAsyncGetHostByName,       
      &PWSACancelAsyncRequest, &PWSAGetLastError                 
  </td>
</tr>

<tr>
  <td>TTXCloseTCP</td>
  <td>This function is called on TCP disconnection, and is not called on Serial connection. When below hooked interface exists, the function should restore an original interface.<br>
      &Pclosesocket, &Pconnect, &Phtonl, &Phtons, &Pinet_addr,   
      &Pioctlsocket, &Precv, &Pselect, &Psend, &Psetsockopt,     
      &Psocket, &PWSAAsyncSelect, &PWSAAsyncGetHostByName,       
      &PWSACancelAsyncRequest, &PWSAGetLastError                 
  </td>
</tr>

<tr>
  <td>TTXSetWinSize</td>
  <td>This function is called when the terminal screen is resized.</td>
</tr>

<tr>
  <td>TTXModifyMenu</td>
  <td>This function is called when the Tera Term menu is initialized. The function can insert new menu on the original menu list.</td>
</tr>

<tr>
  <td>TTXModifyPopupMenu</td>
  <td>This function is called when the Tera Term pop-up menu is initialized. The function can insert new pop-up menu on the original pop-up menu list.</td>
</tr>

<tr>
  <td>TTXProcessCommand</td>
  <td>This function is called when the Tera Term menu is executed. The function can process the plug-in module menu.
  </td>
</tr>

<tr>
  <td>TTXEnd</td>
  <td>This function is called when the Tera Term terminates.</td>
</tr>

<tr>
  <td>TTXSetCommandLine</td>
  <td>This function is called when the command line parameter is processed on new connection and duplicating connection. An original parameter of the plug-in module is processed.
  </td>
</tr>

</table>
 </p>


<hr>



<h2><a name="configuration">Reading and Writing Configuration File</a></h2>
    The registry system is traditionally used on the general Windows application to record the application data. However, Tera Term basically uses the .ini file to reading and writing the application data because the Tera Term's birth goes back to the Windows 3.1. <br>
    The Collector, LogMeTT and CygTerm program included in the Tera Term package are recording the application data to the local storage. <br>
    The TeraTerm Menu records the application data to the registry as an exception. However, the application uses the .ini file instead of the registry when the "ttpmenu.ini"(it is possible to 0 byte) is created on the current directory. Note that your registry data is automatically translated to the .ini file, so you need to configure again. <br>
  <br>
  
    When new entry is added in the teraterm.ini file, the ReadIniFile()#ttset.c is implemented to read the file.

<pre class=code>
	ts->ConfirmChangePaste =
		GetOnOff(Section, "ConfirmChangePaste", FName, TRUE);
</pre>
    
    Also, the WriteIniFile()#ttset.c is implemented to write the file.

<pre class=code>
	WriteOnOff(Section, "ConfirmChangePaste", FName,
		ts->ConfirmChangePaste);
</pre>

    When the entry is set as a string, use the GetPrivateProfileString() and WritePrivateProfileString() Win32 API. 
    However, when the entry is set as an integer, use the GetPrivateProfileInt() and WriteInt() Win32 API. 


<hr>



<h2><a name="secure">Secure Programming</a></h2>

<h3>String Operation</h3>
    A default account of Microsoft Windows has the Administrator privilege except the Windows Vista. When an application has a bug regarding the buffer overflow, the third-party will illegally obtain the Administrator privilege. <br>
    Traditionally, the string operation of C language will happen the buffer overflow problem. So, Microsoft develops the enhanced string operation from Visual Studio 2005. <br>
  <br>

<ul>
  <li><a href="https://msdn.microsoft.com/en-us/library/8ef0s5kh(v=vs.80).aspx">Security Enhancements in the CRT(MSDN Library)</a></li>
</ul>
<br>
    
    Tera Term has replaced every string operation to enhanced version for security problem. Some alternative functions are below shown. <br>
  <br>

<table border=1 align=center>
<tr>
  <th>Old</th>
  <th>New</th>
</tr>

<tr>
  <td>sprintf(), _snprintf()</td>
  <td>_snprintf_s()</td>
</tr>

<tr>
  <td>strcat(), strncat()</td>
  <td>strncat_s()</td>
</tr>

<tr>
  <td>strcpy(), strncpy()</td>
  <td>strncpy_s()</td>
</tr>
</table>
  <br>
  
    These functions cat not work well when the default locale is applied, Tera Term uses the _snprintf_s_l() function instead. <br>
    Every function name has _s("secure") postfix, the function is visually recognized. Rightly, these functions are not compatible with the ANSI C specification. <br>
  <br>
    Also, the Count argument(maximum number of chars to store) is specified to the "_TRUNCATE" macro. When the buffer overflow happens, the copied buffer forcibly truncates.
<p>
    
    Example of using the strncpy_s() function is below shown. The second argument(numberOfElements) is specified with the buffer size <b>including the terminating null(\0)</b>.
    The writing buffer has only three bytes, five bytes data specified by the third argument(strSource) truncates to two bytes. As a result, the buf[] stores the "he\0" string.

<pre class=code>
char buf[3];
strncpy_s(buf, sizeof(buf), "hello", _TRUNCATE);
</pre>

    Next, example of using the strncat_s() function is shown. The first argument(strDest) should have terminating null to concatenate strings. The second argument(numberOfElements) of the strncpy_s() function is specified with the buffer size including terminating null. For below example, when the first code is executed, five bytes(four chars + null) is stored. When the second code is executed, two chars are only copied into the buffer because the buffer size has two bytes. Finally, the buffer stores the "TeraTe"(4 chars + 2 chars + null).
  
<pre class=code>
char str[7];
str[0] = '\0';
strncat_s(str, sizeof(str), "Tera", _TRUNCATE);
strncat_s(str, sizeof(str), "Term", _TRUNCATE);
</pre>
    
    Finally, the _snprintf_s() function uses. Confusingly, the _snprintf() does not use because terminating null may not be added into the buffer. Example of the _snprintf_s() function is below shown. The buf[] has the "ab\0".

<pre class=code>
char buf[3];
_snprintf_s(buf, sizeof(buf), _TRUNCATE, "abcdef");
</pre>


<hr>



<h2><a name="compatibility">Compatibility with Obsolete Windows Versions</a></h2>

<h3>Dynamic Loading</h3>
    Microsoft Windows application can work well on every Windows version by using same executing program, however it is necessary to devise a way to make a programming.<br>
    For example, when the SetLayeredWindowAttributes() API supported on Windows 2000 is directly called, the application can not execute on Windows NT4.0, 98 and so on. So, new API is called by using the LoadLibrary() for dynamic loading. <br>

<pre class=code>
static BOOL MySetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
{
	typedef BOOL (WINAPI *func)(HWND,COLORREF,BYTE,DWORD);
	static HMODULE g_hmodUser32 = NULL;
	static func g_pSetLayeredWindowAttributes = NULL;

	if (g_hmodUser32 == NULL) {
		g_hmodUser32 = LoadLibrary("user32.dll");
		if (g_hmodUser32 == NULL)
			return FALSE;

		g_pSetLayeredWindowAttributes =
			(func)GetProcAddress(g_hmodUser32, "SetLayeredWindowAttributes");
	}

	if (g_pSetLayeredWindowAttributes == NULL)
		return FALSE;

	return g_pSetLayeredWindowAttributes(hwnd, crKey, 
	                                     bAlpha, dwFlags);
}
</pre>
    However, it is too much like work to define a function prototype declaration manually. So, it eliminates complicated procedure by using DLL delay loading.



<h3>Windows 95</h3>
    
    The Visual Studio 2005 or later no longer support the Microsoft Windows 95. Basically, the binary program built by the Visual Studio 2005 can not work on the Windows 95. For your information, the Visual Studio 2008 and 2010 no longer support the Windows 98, NT4.0 and 2000. The Windows XP will not support in the future.
  <p>
      
      Currently, Tera Term can work on the Windows 95 with a method despite Tera Term is built by the Visual Studio 2005. Certainly, this is Microsoft unofficial method. <br>
      The binary program built by the Visual Studio 2005 links the IsDebuggerPresent function by default. The program can not work on the Windows 95 with link error because the function is added from the Windows 98. <br>
      So, this problem can be avoided to define dummy symbol of the IsDebuggerPresent function on the Windows 95. For details, refer to the "comapt_w95.h" header. <br>

<ul>
  <li><a href="https://osdn.jp/projects/ttssh2/svn/view/trunk/teraterm/common/compat_w95.h?view=markup&root=ttssh2">comapt_w95.h</a></li>
</ul>

<hr>


<h2><a name="debug">Debugging Methods</a></h2>
<h3>Debug printf</h3>
    The Windows application can not generally use the printf() function because the standard output is not assigned anywhere on the application. However, the application can use the printf() function by using the AllocConsole() and freopen(). <br>
    The application can display the message on the debug console of the Visual Studio by using the OutputDebugString() API. When the debugger launches, the debugging message can be shown regardless of the "Debug build" and "Release build". So, when a user uses the debugger like as the <a href="http://www.vector.co.jp/soft/win95/prog/se046776.html">DBCon</a> by not using the Visual Studio, the debugging message of the application can be caught. <br>
    
    Tera Term prepares a wrapper function to support the variable argument.
  
<pre class=code>
void OutputDebugPrintf(char *fmt, ...) {
	char tmp[1024];
	va_list arg;
	va_start(arg, fmt);
	_vsnprintf(tmp, sizeof(tmp), fmt, arg);
	OutputDebugString(tmp);
}
</pre>

<h3>Memory leak</h3>
    The memory leak that the heap memory by using malloc() series forgets to free the memory can be automatically detected on the Visual Studio. Below code is inserted on program startup. When the heap memory not freed remains, the Visual Studio will list up the result into the output window of Visual Studio.

<pre class=code>
#ifdef _DEBUG
  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif
</pre>
    
    So, an application program works on the virtual memory like as Windows. When the memory leak exists on terminating the program, the operation system frees the not freed memory.

<hr>


<h2><a name="thread">Multithreading</a></h2>
    Generally, the Windows application will be designed for multithreading, however the multithreading model is not popular from Windows 3.1 to Windows 95. So, Tera Term is not implemented for multithreading model. It comes to understand that Tera Term's source code uses many global variables. In other words, most procedures are not thread-safe. <br>
    However, a part of procedure uses the multithread by using the _beginthreadex() API. Some places generating the thread are in the following:

<p>
<div align=center><b>Tera Term</b></div>
<table border=1 align=center>
<tr>
  <th>Generating point</th>
  <th>Source file</th>
</tr>

<tr>
  <td>Serial connection</td>
  <td>CommStart()#commlib.c</td>
</tr>

<tr>
  <td>TELNET keep-alive</td>
  <td>TelStartKeepAliveThread()#telnet.c</td>
</tr>

<tr>
  <td>IPv4/v6 socket creation</td>
  <td>WSAAsyncGetAddrInfo()#WSAAsyncGetAddrInfo.c</td>
</tr>
</table>

<br>

<div align=center><b>TTSSH</b></div>
<table border=1 align=center>
<tr>
  <th>Generating point</th>
  <th>Source file</th>
</tr>

<tr>
  <td>SSH keep-alive</td>
  <td>start_ssh_heartbeat_thread()#ssh.c</td>
</tr>

<tr>
  <td>SCP sending</td>
  <td>SSH2_scp_tolocal()#ssh.c</td>
</tr>

<tr>
  <td>SCP receiving</td>
  <td>SSH2_scp_fromremote()#ssh.c</td>
</tr>
</table>
</p>

    As already mentioned, the Tera Term including the TTSSH is not thread-safe, so any problem will be happened when new thread is created and the transceiver procedure works on the thread. <br>
    For example, a packet needs to transmit periodically in order to the keep-alive(heart-beat) mechanism for the TELNET and SSH protocol. Also, when the file is transmitted on the SCP protocol, the multithread model is necessary to keep the terminal throughput of the user operation. <br>
    When the multithread model is used on the Tera Term, the mode less window is hidden created and a thread is generated by using the _beginthreadex() API. Next, the actual procedure works on the mode less window. For this method, the thread-safe keeps up while multithreading. The sample code is in the following: <br>

<pre class=code>
#define WM_SEND_HEARTBEAT (WM_USER + 1)

static LRESULT CALLBACK telnet_heartbeat_dlg_proc(HWND hWnd, UINT msg, WPARAM wp, LPARAM lp)
{

	switch (msg) {
		case WM_INITDIALOG:
			return FALSE;

		case WM_SEND_HEARTBEAT:
			TelSendNOP();
			return TRUE;
			break;

		case WM_COMMAND:
			break;

		case WM_CLOSE:
			return TRUE;

		case WM_DESTROY:
			return TRUE;

		default:
			return FALSE;
	}
	return TRUE;
}

static unsigned _stdcall TelKeepAliveThread(void *dummy) {
  static int instance = 0;

  if (instance > 0)
    return 0;
  instance++;

  while (cv.Open && nop_interval > 0) {
    if (time(NULL) >= cv.LastSendTime + nop_interval) {
		SendMessage(keepalive_dialog, WM_SEND_HEARTBEAT, 0, 0);
    }

    Sleep(100);
  }
  instance--;
  return 0;
}

void TelStartKeepAliveThread() {
  unsigned tid;

  if (ts.TelKeepAliveInterval > 0) {
    nop_interval = ts.TelKeepAliveInterval;

	keepalive_dialog = CreateDialog(hInst, MAKEINTRESOURCE(IDD_BROADCAST_DIALOG),
               HVTWin, (DLGPROC)telnet_heartbeat_dlg_proc);

    keepalive_thread = (HANDLE)_beginthreadex(NULL, 0, TelKeepAliveThread, NULL, 0, &tid);
    if (keepalive_thread == (HANDLE)-1) {
      nop_interval = 0;
    }
  }
}
</pre>



<hr>


<h2><a name="dde">DDE Communication</a></h2>
  <h3>Overview</h3>
The DDE(Dynamic Data Exchange) mechanism was born in 1987 of Windows 2.0. The DDE can communicate with process, however the DDE can hardly use now because the DDE is legacy method. The standard interprocess communications are the mailslot, named pipe and OLE. <br>
The DDE spy tool(DDESPY.EXE) that can capture the communication data with the DDE mechanism was once attached in the Visual Studio, however the tool was not found now. <br>
Please refer to the MSDN library for DDE details. <br>

<p>
<ul>
  <li><a href="http://msdn2.microsoft.com/en-us/library/ms648711(VS.85).aspx">Dynamic Data Exchange(MSDN library)</a></li>
  <li><a href="http://msdn2.microsoft.com/en-us/library/ms648712(VS.85).aspx">Dynamic Data Exchange Management Library(MSDN library)</a></li>
</ul>
</p>

The DDE and TCP communication are similar because the protocol connects between a server and a client with peer-to-peer and communicates. The application can use the DDE communication by using the DDEL(Dynamic Data Exchange Management Library) library like as the Win32 API. <br>
One process becomes the server and the other process becomes the client for the DDE communication. Also, the session identification needs to unique the communication session in the system. The TCP communication uses an IP address and a port number, however the DDE communication uses a service name and a topic name. On Tera Term's DDE communication, the service name uses the "TERATERM" string and the topic name uses the string formatted hexadecimal digits which is the window handle(HVTWin) of the Tera Term core. <br>
A macro script can not send the command to quite another Tera Term. <br>

<div align="center">
<img src="image/dde.png" width=720 height=540>
</div>

The Tera Term core("ttermpro.exe") becomes the DDE server and the macro program("ttpmacro.exe") becomes the DDE client on above figure. The DDE payload is called the transaction. The transaction has below some types. The type is defined as macro in the "ddeml.h" file. <br>

<p>
<table border=1 align=center>
<tr>
  <th>Type</th>
  <th>Description</th>
</tr>

<tr>
  <td>XTYP_ADVREQ</td>
  <td>The DDE server sends this message to own in order to send the message from the DDE server to client. </td>
</tr>

<tr>
  <td>XTYP_POKE</td>
  <td>The DDE client sends the data to the DDE server.</td>
</tr>

<tr>
  <td>XTYP_ADVSTART</td>
  <td>The advise loop starts on the DDE server.</td>
</tr>

<tr>
  <td>XTYP_ADVDATA</td>
  <td>This message periodically sends the data to the DDE client.</td>
</tr>

<tr>
  <td>XTYP_EXECUTE</td>
  <td>This message sends a string to the DDE server for specifying the server.</td>
</tr>

</table>
</p>

The DDE communication has as a feature regarding the advise loop. When the DDE server enters the advise loop, the client can periodically receive the data. So, Tera Term uses the advise loop because the received data from the remote host is sent to the macro program. <br>

  <h3>Library</h3>
The DDEML that is used on Tera Term is described as follows.
  
  
<p>
<table border=1 align=center>
<tr>
  <th>Function</th>
  <th>Description</th>
</tr>

<tr>
  <td>DdeInitialize</td>
  <td>This function initialized the DDE and registers the callback function. If the function succeeds, the instance returns.</td>
</tr>

<tr>
  <td>DdeCreateStringHandle</td>
  <td>This function creates a handle from  a string. The handle is used for communications the server and client. </td>
</tr>

<tr>
  <td>DdeNameService</td>
  <td>This function registers the instance and the service name("TERATERM") on the DDE server. If the registration succeeds, the XTYP_REGISTER transaction is send to the DDE client. Also, this function uses for unregistration. </td>
</tr>

<tr>
  <td>DdeCmpStringHandles</td>
  <td>This function compares two string handles.</td>
</tr>

<tr>
  <td>DdeClientTransaction</td>
  <td>This function sends a transaction from client to server. The type of transactions can be specified with the XTYP_REQUEST, XTYP_EXECUTE, XTYP_ADVSTART, XTYP_POKE and so on. A timeout value that can wait until a server's ACK, and the value is almost specified with the 1000 milliseconds(1 second). However, the 5000 milliseconds(5 seconds) is specified when the Tera Term confirms the ACK. </td>   
</tr>

<tr>
  <td>DdeAccessData</td>
  <td>This function retrieves a point of data from the DDE handle. If the pointer is not required, the DdeUnaccessData() must be called. </td>
</tr>

<tr>
  <td>DdeCreateDataHandle</td>
  <td>This function creates the DDE object and returns the handle. The handle is used for the DDE server's advise loop, also sending a data to the DDE client when the XTYP_REQUEST transaction is received. </td>
</tr>

<tr>
  <td>DdeGetData</td>
  <td>This function copies from the DDE object to th buffer.</td>
</tr>

<tr>
  <td>DdeDisconnect</td>
  <td>This function terminates the DDE communication.</td>
</tr>

<tr>
  <td>DdePostAdvise</td>
  <td>This function uses at the DDE server and sends the XTYP_ADVREQ transaction to own. </td>
</tr>

</table>
</p>



  <h3>Implementation</h3>
The DDE server implementation are described in this chapter. The Tera Term core("ttermpro.exe") becomes the DDE server, so the DDE server is launched at first. When the macro program("ttpmacro.exe") is directly called the macro script, the DDE communication can not start until the DDE connects by using the "connect" macro command. <br>
When the Macro menu is called under the Control menu in Tera Term, the RunMacro()#ttdde.c is called. <br>
A topic name(8 bytes) is created from the HVTWin window handle, and the DDE is initialized and the server is registered. Also, the DDE buffer(1KB) is created at this timing. At last, the "ttpmacro.exe" with /D option is passed the topic name and launched. <br>
  
<pre class=code>
	SetTopic();
	if (! InitDDE()) return;
	strncpy_s(Cmnd, sizeof(Cmnd),"TTPMACRO /D=", _TRUNCATE);
	strncat_s(Cmnd,sizeof(Cmnd),TopicName,_TRUNCATE);
</pre>

When the transaction is sent to th DDE sever from the DDE client, the DdeCallbackProc callback function executes. The callback function is registered when the DDE is initialized by the DdeInitialize(). <br><br>

Next, please see the DDE client implementation. The InitDDE()#ttmdde.c is called on the macro program startup, and the DDE client is initialized. The DdeInitialize() initializes the DDE and registers the DdeCallbackProc callback function. The transaction which is sent from the DDE server is processed in the callback. <br>
When the DDE communication starts, the DdeConnect() must be called and connect to the DDE server. Next, the XTYP_EXECUTE transaction sends to notify the window handle(HWin) of the "ttpmacro.exe". Finally, the XTYP_ADVSTART transaction sends to the server and starts the advise loop. <br>

<pre class=code>
  ConvH = DdeConnect(Inst, Service, Topic, NULL);
  if (ConvH == 0) return FALSE;
  Linked = TRUE;

  Cmd[0] = CmdSetHWnd;
  w = HIWORD(HWin);
  Word2HexStr(w,&(Cmd[1]));
  w = LOWORD(HWin);
  Word2HexStr(w,&(Cmd[5]));

  DdeClientTransaction(Cmd,strlen(Cmd)+1,ConvH,0,
    CF_OEMTEXT,XTYP_EXECUTE,1000,NULL);

  DdeClientTransaction(NULL,0,ConvH,Item,
    CF_OEMTEXT,XTYP_ADVSTART,1000,NULL);
</pre>


  <h3>Buffer Management</h3>
The macro program can snoop the data which is sent from the remote host by using "wait" like commands. Regarding this feature, both the Tera Term core and the macro program prepares the buffer, and the Tera Term core sends the received data from the remote host to the macro program by using the DDE communication(DDE transaction). <br>

<div align="center">
<img src="image/dde_flowcontrol.png" width=720 height=540>
</div>

First, the Tera Term core which receives the TCP packet from the remote host is implemented at the OnIdle()#teraterm.cpp file. The CommReceive()#commlib.c which is called from the OnIdle() stores the TCP packet data into the buffer(cv->InBuff[]). This buffer size is 1KB. Also, when the buffer is full, the TCP packet does not store to the buffer because the buffer is not ring buffer. However, when the buffer full state continues for a long time, the TCP packet will gather at the Windows internal kernel and the Tera Term will not receive the data from the remote host. <br>

When the log is retrieving and the macro is executing in analyzing the escape sequence process, the LogPut1() stores the received data to the DDE buffer(cv.LogBuf[]). In other words, the logging and the macro executing are common buffer. The buffer size is 1KB and ring buffer, so the oldest data is overwritten when the buffer is full. <br>

Also, when the logging is enabled by the binary mode, the data is stored into the other cv.BinBuf[]. In other words, the data of the binary mode can not communicate with the DDE mechanism. So, the binary data can not wait by using the "wait" series command. <br>

When the escape sequence finishes analyzing, the DDEAdv()#ttdde.c is called soon and the XTYP_ADVREQ transaction is sent to own(DDE server). When the XTYP_ADVREQ transaction is received, the DdeCallbackProc() is called and the DDE buffer of the Tera Term core are sent to the macro program. The advise loop is used in here. <br>

<div align="center">
<img src="image/dde_buffer.png" width=720 height=540>
</div>

The data is received from the DDE server at the advise loop and the XTYP_ADVDATA transaction is processed at the DdeCallbackProc()#ttmdde.c of the macro program as the DDE client. <br>

Also, the DDE communication buffer and the log buffer are shared in the cv.LogBuf[] on the Tera Term core. The buffer head and size index are "DStart" and "Dcount" in case of the DDE communication, "LStart" and "Lcount" in case of the logging. Actually, if each index is differ, the program will not work well, so the two indexes must always synchronize. <br>
  
<hr>

        

<h2><a name="ttssh">SSH Design and Implementation in TTSSH</a></h2>
<!--
  <h3>概要</h3>
  オリジナルのTTSSHは<a href="http://www.cs.cmu.edu/People/roc/">Robert O'Callahan</a>氏（現在は<a href="http://weblogs.mozillazine.org/roc/">Mozilla hacker</a>として活躍）により開発されたプラグインです。SSH1へ対応しており、ポートフォワーディングやzlibによるパケット圧縮もサポートしていました。TTSSHは、Tera Termをセキュア通信に対応させるためのプラグインであったために、SCPやSFTP等には未対応でした。オリジナルTera Termが1998年に開発凍結後も、2001年ごろまでメンテナンスが続けられていました。<br>
  TTSSHのSSH2対応を実現するために、TeraTerm Projectにより2004年から設計と実装が始められました。3年の歳月をかけて、ほぼSSH2プロトコルのフルサポートを実現しました。現在ではSCPへも対応しています。将来的にはSFTPへも対応されるかもしれません。<br>
  原則、TTSSHの実装は<a href="http://www.openssh.com/">OpenSSH</a>を参考にしています。一部、コードをそのまま流用しているところもあります。ただし、OpenSSHはUNIXのコマンドライン向けに設計されているため、Tera TermのようなWindowsアプリケーションにはそのまま適合しない箇所も多く、フレームワークとしてはOpenSSHと大きく異なったものとなっています。<br>


  <h3>SSHプロトコル</h3>
  SSH(Secure Shell)は、バージョン1（厳密には1.5）とバージョン2が存在し、略して"SSH1"および"SSH2"と呼ばれます。それらのバージョン間にはプロトコル仕様としての互換性はありません。SSH1にはセキュリティ上の問題があるために、現在はほとんど利用されません。<br>
  SSH2プロトコルの仕様に関しては、RFC化されています。
  
<p>
<ul>
  <li><a href="http://www.ietf.org/rfc/rfc4250.txt">RFC4250: The Secure Shell (SSH) Protocol Assigned Numbers</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc4251.txt">RFC4251: The Secure Shell (SSH) Protocol Architecture</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc4252.txt">RFC4252: The Secure Shell (SSH) Authentication Protocol</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc4253.txt">RFC4253: The Secure Shell (SSH) Transport Layer Protocol</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc4254.txt">RFC4254: The Secure Shell (SSH) Connection Protocol</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc4255.txt">RFC4255: Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc4256.txt">RFC4256: Generic Message Exchange Authentication for the Secure Shell Protocol (SSH)</a></li>
  <li><a href="http://www.ietf.org/rfc/rfc4344.txt">RFC4344: The Secure Shell (SSH) Transport Layer Encryption Modes</a></li>

</ul>
</p>


  <h3>接続処理</h3>
  TTSSHは、Tera Termの一部のコードでもあるため、ネットワーク接続処理はTera TermとTTSSHの間を行き来することになり、処理の流れが複雑になっています。また、SSHプロトコルそのもののフローを熟知していないと、TTSSHのシーケンスを追っていくのが難しくなっています。以下に、リモートホストへの接続を行うまでのフローを示します。<br>

<div align="center">
<img src="image/ssh.png" width=720 height=540>
</div>


  <h3>送信パケット処理</h3>
  SSH2プロトコルに載せて、パケットをサーバへ送るときのコードは以下のような書き方となります。begin_send_packet()の呼び出しで、「pvar->ssh_state.outbuf + 12」が返り値となり、それがペイロードを表します。ペイロードは純粋にサーバへ送りたいデータのことで、サイズやパディング等を含みません。<br>
  
<pre class=code>
	buffer_t *msg;
	int len;
	char *s;
	unsigned char *outmsg;
	
	msg = buffer_init();
	if (msg != NULL) {
		buffer_put_int(msg, SSH2_DISCONNECT_PROTOCOL_ERROR);
		s = "disconnected by server request";
		buffer_put_string(msg, s, strlen(s));
		s = "";
		buffer_put_string(msg, s, strlen(s));

		len = buffer_len(msg);
		outmsg = begin_send_packet(pvar, SSH2_MSG_DISCONNECT, len);
		memcpy(outmsg, buffer_ptr(msg), len);
		finish_send_packet(pvar);
		buffer_free(msg);
	}
</pre>

  SSH通信に載せられて、実際にパケットが送出されるのは、finish_send_packet()から呼び出される finish_send_packet_special() です。パケットを送信するときのフォーマットについて、以下に示します。共通鍵暗号でパケットデータを暗号化する前に、ヘッダとフッタを付ける必要があります。<br>
  パケットサイズはHMACを除く長さです。パケットサイズそのものはビッグエンディアン形式で、4バイト分格納しますが、その"4"バイトは含まれません。ペイロードの直後にパディングを埋めるのは、共通鍵暗号で暗号化するときに「ブロックサイズ単位」になっていなければ、アルゴリズム的に暗号化できないからです。ブロックサイズは暗号アルゴリズムにより異なり、たとえば3DES-CBCならば24バイト、AES128ならば16バイトです。<br>
  HMAC(Keyed-Hashing for Message Authentication)は、暗号化本文に対するハッシュです。ハッシュのアルゴリズムは選択可能であり、"MD5"や"SHA-1"がよく使われています。HMACを付加することにより、「第三者によるデータの改ざん」を検出することができます。HMACは、暗号化対象となる本文を秘密鍵とシーケンス番号を加え、ハッシュ値を計算します。秘密鍵とシーケンス番号を加えることにより、第三者がデータをまるごと差し替えたとしても、送信者が生成したハッシュ値を復元することは理論上できません。<br>
  

<div align="center">
<img src="image/ssh_packet_format1.png" width=720 height=540>
</div>

  zlibによるパケット圧縮を行う場合における、パケットを送信するときのフォーマットについて、以下に示します。パケット圧縮を行うのは、「ペイロード」の部分のみで、残りは通常の送信パケットとフォーマットは同じです。なお、パケットを圧縮したとしても、かならずしも元のサイズよりも小さくなるとは限らないので、そのことを考慮したバッファ管理が必要です。<br>
  パケット圧縮送信で難しいのは、圧縮を開始するタイミングです。ローカルホストからリモートホストへのSSH接続を開始すると、実にたくさんのネゴシエーションが行われますが、パケットを圧縮してよいのは決められたタイミングであり、このタイミングを間違えると、サーバとまったく通信ができなくなります。<br>
  通常のパケット圧縮の場合は、"SSH2_MSG_KEXINIT"を受信したタイミングです。遅延パケット圧縮の場合は、ユーザ認証が成功したタイミング（"SSH2_MSG_USERAUTH_SUCCESS"を受信した時）です。遅延パケット圧縮というのは、それまで"SSH2_MSG_KEXINIT"を受信したタイミングで圧縮を開始していたのを、ユーザ認証が完了するまで延長する方式です。遅延パケット圧縮は、zlibライブラリのセキュリティホールにより、不正なSSHサーバへ接続しただけで、クライアント側に影響が出るのを回避するためのしくみです。


<div align="center">
<img src="image/ssh_packet_format2.png" width=720 height=540>
</div>


  <h3>受信パケット処理</h3>
  パケットの受信は、TeraTerm本体側からは recv ソケット関数を呼び出した場合に、それがTELNETなのかSSHなのかを意識させないような設計になっていることと、 recv ソケット関数の呼び出しでは、かならずしも十分なバッファサイズが指定されてくるとは限らないため、少々実装が複雑になっています。<br>

<div align="center">
<img src="image/ssh_recv_packet.png" width=720 height=540>
</div>

  TeraTerm本体側は OnIdle()#teraterm.cpp というアイドルループにおいて、常時パケットの受信がないかをポーリングしています。それが CommReceive() で、recv()を呼び出します。recv()はTTSSHによりフックされているので、ソケット関数ではなく、TTXrecv()#ttxssh.c が呼び出されます。<br>
  CommReceive()は recv() を呼び出す際に、バッファ(cv->InBuff[])の空きポインタとサイズを引数に渡します。バッファサイズは 1KB です。つまり、TTXrecv()のサイズには、1～1024 までの数値が渡される可能性があるということです。<br>
  TTXrecv()から呼び出される PKT_recv() は、少々複雑なループ処理となっています。SSH接続を初めて行うときのシーケンスを以下に示します。
  
<ol>
 <li>recv_data() で本当の recv() を呼び出し、サーバからの受信パケットをカーネルから受け取る。pvar->pkt_state.datalenが更新される。 </li>
 <li>SSH_handle_server_ID() でSSHサーバのバージョンチェックが行われる。pvar->pkt_state.datastart と pvar->pkt_state.datalen を更新する。</li>
 <li>再度、recv_data() が呼ばれるが、サーバからの受信データがもうないので、connection_closed=TRUE として while ループを抜ける。</li>
 <li>TeraTermの recv() は"0"で返ってくる。すなわち、受信データなし。</li>
</ol>

  次に、SSH通信のための共通鍵生成までのシーケンスを以下に示します。

<ol>
 <li>recv_data() で本当の recv() を呼び出し、サーバからの受信パケットをカーネルから受け取る。pvar->pkt_state.datalenが更新される。 </li>
 <li>SSH_predecrpyt_packet() で、受信パケットの先頭ブロックのみを復号化する。SSHパケットのサイズを取得する。</li>
 <li>妥当なSSHパケットサイズならば、SSH_handle_packet() を呼び出し、メッセージタイプに応じたハンドラを呼び出す。pvar->ssh_state.payload と pvar->ssh_state.payloadlen を設定する。</li>
 <li>pvar->pkt_state.datastart と pvar->pkt_state.datalen を更新する。</li>
 <li>pvar->pkt_state.datalen がゼロになるまで、SSH_predecrpyt_packet() の処理を繰り返す。</li>
 <li>recv_data() が呼ばれるが、サーバからの受信データがもうないので、connection_closed=TRUE として while ループを抜ける。</li>
 <li>TeraTermの recv() は"0"で返ってくる。すなわち、受信データなし。</li>
</ol>

  次に、端末データ通信のシーケンスを以下に示します。

<ol>
 <li>recv_data() で本当の recv() を呼び出し、サーバからの受信パケットをカーネルから受け取る。pvar->pkt_state.datalenが更新される。 </li>
 <li>SSH_predecrpyt_packet() で、受信パケットの先頭ブロックのみを復号化する。SSHパケットのサイズを取得する。</li>
 <li>妥当なSSHパケットサイズならば、SSH_handle_packet() を呼び出し、メッセージタイプに応じたハンドラを呼び出す。pvar->ssh_state.payload と pvar->ssh_state.payloadlen を設定する。</li>
 <li>メッセージタイプがSSH2_MSG_CHANNEL_DATAなので、handle_SSH2_channel_data() を呼び出す。pvar->ssh_state.payload_datalen と pvar->ssh_state.payload_datastart を設定する。</li>
 <li>pvar->pkt_state.datastart と pvar->pkt_state.datalen を更新する。</li>
 <li>SSH_is_any_payload() が真を返すようになり、PKT_recv()に渡されてきたバッファへデータをコピーする。</li>
 <li>TeraTerm側のバッファサイズがいっぱいになった場合は、SSH端末データが残っていたとしても、PKT_recv()は返る。</li>
 <li>TeraTerm側のバッファサイズに余裕がある場合は、recv_data()を呼び出し、サーバからの受信データを取得する。</li>
 <li>TeraTermの recv() は「受信データサイズ」で返ってくる。</li>
</ol>


  <h3>シーケンス制御</h3>
  SSH2接続を行うことで、通信経路を暗号化することができるのが特徴ですが、パケットの暗号化を行うためには、「鍵」が必要です。通信経路の暗号化には、共通鍵による共通鍵暗号が利用されます。公開鍵暗号のほうがセキュリティ強度は高いのですが、暗号処理に多大な時間がかかるため、SSHのような通信性能が要求されるしくみでは採用されません。SSH2では、共通鍵暗号アルゴリズムとして、AES(Advanced Encryption Standard：Rijndaelアルゴリズム)や3DES(Triple DES)などが利用されます。<br>
  共通鍵は通信を行う二者間でのみに共有される情報であり、第三者に知られてはなりません。SSH2では、クライアントがリモートホスト（SSHサーバ）へTCP接続した時に、"Diffie-Hellman"アルゴリズムをベースとした独自の方式により、クライアントとサーバでしか知り得ないDH(Diffie-Hellman)鍵を生成します。DH鍵生成までの過程は、ネットワーク上をパケットが平文で流れるため、第三者によるパケットキャプチャが可能となっていますが、パケットを覗かれても、DH鍵は理論上第三者には分からないようになっています。<br>
  共通鍵が生成できたあとは、その鍵を使ってパケットを暗号化します。SSH2では、送受信されるパケットは種類があるため、それぞれに「メッセージ番号」を割り振っています。RFC4250にメッセージ番号の一覧があります。メッセージ名は"SSH2_MSG_xxxx"というネーミングになっており、TTSSH内部でも同じ名前でマクロ定義しています。<br>
  以下に、クライアントからサーバへTCP接続（ポート22番）してから、パスワード認証でユーザ認証されるまでの流れを示します。<br>


<div align="center">
<img src="image/ssh2_sequence1.png" width=720 height=540>
</div>

<div align="center">
<img src="image/ssh2_sequence2.png" width=720 height=540>
</div>

  以下は、リモートホストのシェル上で"exit"や"logout"として、クライアントから明示的にシェルをクローズするときの、パケットの流れを示しています。<br>

<div align="center">
<img src="image/ssh2_sequence3.png" width=720 height=540>
</div>

  TTSSHは、SSH2でパスワード認証のほかにkeyboard-interactive認証、publickey認証、Pageantを利用したpublickey認証をサポートしています。それぞれの認証方式でどのようなシーケンスで認証が行われるのか、以下に示します。

<div align="center">
<img src="image/ssh2_auth1.png" width=720 height=540>
</div>
<div align="center">
<img src="image/ssh2_auth2.png" width=720 height=540>
</div>



  <h3>疑似端末のしくみ</h3>
  SSH2では、新しく「フロー制御」という概念が取り込まれています。TCPのウィンドウと同じ考え方で、「ウィンドウサイズ」というしくみを導入しています。この機能により、クライアント（Tera Term）とサーバ（SSHデーモン）間において、フロー制御が働くため、原則データが溢れることはありません。<br>
  ところで、SSH2におけるフロー制御があるにも関わらず、大量のクリップボードをTeraTermの端末へペーストすると、サーバ側での「データの取りこぼし」が発生することがあります。この現象を理解するためには、UNIXにおける疑似端末（PTY: pseudo-terminal）の動作原理を知る必要があります。

<div align="center">
<img src="image/pty.png" width=720 height=540>
</div>

  SSHデーモン(sshd)はクライアントに対して、あたかもサーバ側のシェルが直接接続されているかのように見せる必要があります。逆に、シェル上で動くプログラムは、文字を送りたいときは printf(3) を、文字を受け取りたい場合は scanf(3) といったCライブラリ関数を呼び出すだけでよく、その先がシリアルコンソールなのか、VGAコンソールなのか、SSH接続されているのかは、一切気にしなくてよいようになっています。<br>
  sshdは、クライアントからの接続要求があったタイミングで、openpty(3)を使って、疑似端末の初期化を行います。疑似端末では、カーネル空間でクライアントとサーバをつなぐために、「マスターデバイスドライバ」と「スレーブデバイスドライバ」が用意されます。マスターデバイスドライバが担当するデバイスファイルは"/dev/ptyXX"、スレーブデバイスドライバでは"/dev/ttyXX"です。つまり、sshdはマスターデバイスドライバへアクセスすることで、シェルとお話をすることができます。シェルは、sshdからforkされて子プロセスとなり、親プロセス(sshd)が初期化済みのスレーブデバイスドライバとお話をすることになります。この疑似端末のしくみにより、sshdとシェルが接続されます。<br>
  なお、端末ラインディシプリン(line discipline: 回線規約)というのは、たとえばプログラムが getchar() を呼び出したときに、Enterキーを押下するまで、プログラムに制御が渡りません。端末ラインディシプリンは、プログラム実行中での「行内編集」を可能とするためのモジュールです。Linuxでは、端末ラインディシプリンは /proc/tty/ldiscs で確認できます（N_TTYが標準的に利用される）。


  <h3>SCP(Secure Copy)</h3>
  SCPは OpenSSH パッケージに含まれるプログラムの1つであり、SSHセッションを使ってファイルの送受信を行うことができます。SCPを利用するためには、リモートサーバに"sshd"だけではなく、"scp"コマンドも導入されている必要があります。OpenSSHのSCPは、sshd デーモンから"scp"コマンドが子プロセスとして起動されることで実現されています。なお、SCPとSFTP(Secure File Transfer Program)はまったく別のプロトコルで、互換性はなく、SCPは純粋にファイルの「送信」と「受信」しかできません。<br>
  SSHセッション上でファイル転送を行うには、クライアントからサーバへ接続が成功したあとに、シェルオープン(pty-req)の代わりに、「外部コマンドの実行」(exec)という形式で、SCPが利用できるようになります。
  
  <p><font size=3>・SSH2の場合</font></p>
  SSH2_MSG_CHANNEL_REQUEST をサーバへ送るときに、"pty-req"の代わりに"exec"をサービス名として指定すると、外部コマンドを実行することができます。
<pre>
    ユーザ認証成功後
         ----&gt; SSH2_MSG_CHANNEL_OPEN(90)
         &lt;---- SSH2_MSG_CHANNEL_OPEN_CONFIRMATION(91)
         ----&gt; SSH2_MSG_CHANNEL_REQUEST(98)  サービス名&quot;exec&quot;で外部コマンド送信(&quot;scp -f&quot;)
         &lt;---- SSH2_MSG_CHANNEL_WINDOW_ADJUST  (remote_window+=131072バイト)
         &lt;---- SSH2_MSG_CHANNEL_EXTENDED_DATA  (local_window-=36バイト)
         &lt;---- SSH2_MSG_CHANNEL_DATA(94)
</pre>

  <p><font size=3>・SSH1の場合</font></p>
    セッションを開くときに、SSH_CMSG_EXEC_CMD をサーバへ送ると、外部コマンドを実行することができます。
  
  <p><font size=3>・外部コマンドの書式</font></p>
<pre>
  * "scp [-v] [-r] [-p] [-d] -t ファイル名"  ローカルからリモートへのコピー
  * "scp [-v] [-r] [-p] [-d] -f ファイル名"  リモートからローカルへのコピー
     -v verbose
     -r リカーシブ
     -p タイムスタンプ保持
     -d ディレクトリ
     -t Local-to-Remoteへコピー
     -f Remote-to-Localへコピー
</pre>

  <p><font size=3>・データ転送</font></p>
    外部コマンドの送信が完了したあとに、ファイルの内容を送信および受信することができます。
<pre>
    １．送信の流れ
      ・"Tタイムスタンプ 0 タイムスタンプ 0"を送信（オプション）
      ・"C0666 サイズ ファイル名"を送信
      ・ファイルの内容を送信
      ・セッションクローズ

    ２．受信の流れ
      ・"Tタイムスタンプ 0 タイムスタンプ 0"を受信（オプション）
      ・0を送信
      ・"C0666 サイズ ファイル名"を受信
      ・0を送信
      ・ファイルの内容を受信
      ・ファイルのタイムスタンプを設定（オプション）
      ・0を送信
      ・セッションクローズ
</pre>

  <p><font size=3>・注意事項</font></p>
    ファイル名にディレクトリが含まれるときは、パスの区切りは「/」となります。「\」は受け付けないので、変換が必要です。



  <h3>X11転送</h3>
  X11転送(X11 port forwarding)は、SSHサーバ上でXウィンドウアプリケーションを起動し、アプリケーションのGUI画面をTera Termが動作しているコンソールPCに飛ばすしくみです。このしくみを使うと、SSHセッション上で"xeyes"や"firefox"、"xemacs"などのソフトウェアを動かすことができるようになります。なお、コンソールPC上には、Xming(http://sourceforge.net/projects/xming/)などのXサーバをあらかじめ用意しておく必要があります。<br>
  下図にX11転送のフローを示します。図を見ると分かるように、Tera Term(TTSSH)はXアプリケーションとXサーバをつなぐ橋渡しの役目を持ちます。このようなTera Termのことを"Redirector"や"Port forwarder"、"TCP proxy"と呼びます。

<div align="center">
<img src="image/x11forward.png" width=720 height=540>
</div>

  X11転送を利用するためには、Tera TermおよびSSHサーバの双方に事前設定が必要です。まず、Tera Termのほうはteraterm.iniに下記の設定が必要です。

<pre class=code>
[TTSSH]
DefaultForwarding=X
</pre>

  SSHサーバのほうは、OpenSSHを例に挙げると、"sshd_config"に下記の設定が必要です。デフォルトは"no"になっているため、通常はデフォルトではX11転送が使えません。

<pre class=code>
X11Forwarding=yes
</pre>

  Tera TermはX11転送が有効であると、spec.typeに"FWD_REMOTE_X11_TO_LOCAL"を設定します。これはSSHサーバ側からTera Term側に向かって、X11転送を行うことを意味します。Tera Termは、リモートホストにSSH接続する際、セッションオープン後の"SSH2_MSG_CHANNEL_OPEN_CONFIRMATION"において、X11転送の初期化を行います。

<pre class=code>
	if (c->type == TYPE_SHELL) {
		// ポートフォワーディングの準備 (2005.2.26, 2005.6.21 yutaka)
		// シェルオープンしたあとに X11 の要求を出さなくてはならない。(2005.7.3 yutaka)
		FWD_prep_forwarding(pvar);
		FWD_enter_interactive_mode(pvar);
	}
</pre>

  FWD_prep_forwarding()では、"x11-req"サービス名と"MIT-MAGIC-COOKIE-1"をSSHサーバに送信し、SSHサーバ側のX11転送の初期化を促します。SSH接続時にX11の初期化が完了すると、SSHサーバ側に環境変数"DISPLAY"が自動的に設定されます。

<pre class=code>
# echo $DISPLAY
DISPLAY=localhost:10.0
</pre>

  ここまで準備が整うと、SSHサーバ上でXアプリケーションを起動させることができます。XアプリケーションからXサーバ、すなわちSSHサーバからTera Termへ送られてくるデータは、SSH2_MSG_CHANNEL_DATA メッセージ形式となります。当該メッセージは FWD_received_data() で処理され、Xサーバ(TCP/6000)へ送られます。Xサーバのソケットは channel->local_socket で、ノンブロッキングモードで扱われます。そのため、一度でパケットを全部送れない場合があるため、送れなかったデータは内部バッファに溜めておく必要があります。また、channel->local_socket にパケットをsendすることにより、FD_WRITE メッセージが発生し、write_local_connection_buffer() が呼び出されます。ここでは、前回送れなかったデータがあれば、内部バッファから取り出し、再度Xサーバへの送信を試みます。<br>
  反対に、Xサーバ、すなわちX11の画面上で何らかの操作が行われた場合、Tera TermからSSHサーバにデータを送信する必要があります。このとき、Tera Termへは FD_READ メッセージが発生し、read_local_connection() が呼び出されます。ここでは、Xサーバから送られてきたデータを SSH2_MSG_CHANNEL_DATA メッセージ形式に載せて、SSHサーバへ送ります。

-->
<hr>


<h2><a name="macro">Macro Language Design and Implementation</a></h2>
  <h3>Overview</h3>
Tera Term macro script is BASIC-style language. It does not use Bison or Flex like lexical analyzer and is written entirely from the scratch using recursive descent parsing method. Therefore, from this point of view Tera Term macro can not be called a full-fledged scripting language.<br>
  
  <h3>Loading Macro File</h3>
As soon as ttpmacro.exe starts, it reads entire macro file (.ttl) into the buffer.
  
<p><ul>
  <li>OnInitDialog()#ttmmain.cpp -> InitTTL() -> InitBuff() -> LoadMacroFile()</li>
</ul></p>

When ttpmacro.exe reads the content of macro file, it places it into buffer Buff[0]#ttmbuff.c. At this point, since entire content of macro has been read, even accidental deletion of macro file during macro execution will not cause a problem. However, if macro contains "include" statements, included files should exist at the time when "include" macro command is being executed.
  
<pre class=code>
#define MAXNESTLEVEL 10     /* defines the maximum number of nested files (up to nine includes) */

static int INest;     /* current nested number */
static HANDLE BuffHandle[MAXNESTLEVEL];   /* buffer handle received from GlobalAlloc () */
static PCHAR Buff[MAXNESTLEVEL];          /* buffer area */
static BINT BuffLen[MAXNESTLEVEL];        /* file size (buffer size) */
static BINT BuffPtr[MAXNESTLEVEL];        /* offset of buffer (read position) */
</pre>


  <h3>Macro Engine</h3>
Macro script processing is done within idle loop OnIdle()#ttmmain.cpp. Behavior of macro engine changes depending on the value of idle loop variable TTLStatus. Normal execution state is set IdTTLRun. The list of available operations is shown below.

<p>
<table border=1 align=center>
<tr>
  <th>Condition</th>
  <th>Handling</th>
</tr>

<tr>
  <td>TTLStatus==IdTTLEnd</td>
  <td>Ends the macro program</td>
</tr>

<tr>
  <td>Unhandled Data (OutLine>0)</td>
  <td>Sends data to Tera Term core</td>
</tr>

<tr>
  <td>TTLStatus==IdTTLRun</td>
  <td>Run the macro line by line</td>
</tr>

<tr>
  <td>TTLStatus==IdTTLWait</td>
  <td>Waits ('wait' command)</td>
</tr>

<tr>
  <td>TTLStatus==IdTTLWaitLn</td>
  <td>Waits ('waitln' command)</td>
</tr>

<tr>
  <td>TTLStatus==IdTTLWaitNL</td>
  <td>Receives line ('recvln' command)</td>
</tr>

<tr>
  <td>TTLStatus==IdTTLWait2</td>
  <td>Waits for string ('waitrecv' command)</td>
</tr>

</table>
 </p>


  <h3>Command Interpretation</h3>
Every time function Exec()#ttl.c is called from the idle loop, the next line of the loaded macro will be processed. GetNewLine() takes one row out of the buffer and saves it in LineBuff[]#ttmparse.c. Any code with ASCII value below 0x20 (whitespace) except 0x09 (tabulation) is considered as the end of line. Leading space and tabulation are ignored. Semicolon (;) is considered as the beginning of a comment and is discarded together with the remaining part of the string. <br>

<pre class=code>
char LineBuff[MaxLineLen];      /* one row can store up to 500 bytes */
WORD LinePtr;       /* buffer offset */
WORD LineLen;       /* buffer size */
</pre>

ExecCmnd() function called from Exec() performs lexical analysis of the commands. Lexical analysis is done by simple string search within LineBuff[], one byte at a time. High level description of the analysis algorithm is shown below.

<p><ol>
  <li>Find 'endwhile'</li>
  <li>Find 'break'</li>
  <li>Find 'endif'</li>
  <li>Find 'else'</li>
  <li>Execute macro command</li>
  <li>Determine identifier</li>
  <li>Show error if none of above steps were executed</li>
</ol></p>

GetReservedWord() function is responsible for detecting whether the input string contains a macro command, or not. Comparison is done by using _stricmp() function, thus the commands are not case sensitive. If supported macro command is detected then corresponding TTLxxx() function is being called. <br>

GetIdentifier() function is responsible for finding identificators. All tokens containing alphanumeric (a-z, A-Z, 0-9) characters, or underscore (_) and not exceeding 32 characters in length will be treated as variables. Statements where a value is assigned to a variable may contain variable name at the left immediately followed by equal sign (=). This complicates variable name detection process. Determination in done in the following order: <br>
  
<p><ol>
  <li>Find a string</li>
  <li>Find a formula</li>
</ol></p>

GetString() function is responsible for finding string values. Since string are surrounded by singe or double quotas ('or "), it is easy to retrieve them. <br>
GetExpression() function detects the formulas that require calculations. It uses recursive descent method for parsing. <br>
CheckVar() function can tell whether the variable exists and if it has numeric or string type. If variable not found, NewStrVar() function will register a new variable. <br>
 

<hr>



<h2><a name="caret">Caret Control</a></h2>
  <h3>Overview</h3>
Usually user moves the cursor by pressing corresponding keys on the keyboard, but if server needs to move the cursor, it sends out escape sequences (sets of characters that start with ESC code). Furthermore, terminal window may be in inactive mode, for example while running in broadcast mode, but it still should be able to move the cursor to simultaneously update multiple terminal windows.
<br>

  <h3>System Caret</h3>
Tera Term uses system caret to draw the cursor. For this purpose Tera Term utilizes API functions listed below. 

<p><ul>
  <li>CreateCaret</li>
  <li>DestroyCaret</li>
  <li>GetCaretBlinkTime</li>
  <li>HideCaret</li>
  <li>SetCaretBlinkTime</li>
  <li>SetCaretPos</li>
  <li>ShowCaret</li>
</ul></p>

According to MSDN Library description of <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms648399(v=vs.85).aspx">CreateCaret function</a>, 

<pre>
The system provides one caret per queue. A window should create 
a caret only when it has the keyboard focus or is active. 
The window should destroy the caret before losing the keyboard 
focus or becoming inactive. 
</pre>

Above requirement means that CreateCaret() can be called only when the window is active and DestroyCaret() should be called before the window becomes inactive. <br>
Caret is displayed by CaretOn()#vtdisp.c function and erased by CaretOff()#vtdisp.c function. These functions are usually called as the result of processing escape sequences parsed by VTParse() function, or when user resizes terminal window with own mouse. <br>


  <h3>Displaying Caret in Inactive Mode </h3>
In inactive windows system caret is invisible. The top window on Windows desktop is the only window that shows the caret. In most cases such behavior is acceptable and doesn't cause problems. <br>
However, when Tera Term is in broadcast mode, active Tera Term window can receive and show commands simultaneously with other inactive Tera Term windows and it will look awkward if during this process the caret in inactive windows is hidden. <br>
Therefore, even if the window is inactive, we have to find a way to draw the caret in it. Since system caret cannot be used, we need to draw our own caret. In this case inactive Tera Term window will be able to show and move cursor in response to escape sequences received from remote host, or following user's input from the keyboard.  <br><br>

Current cursor position is stored in CursorX and CursorY. CaretKillFocus() function is called for inactive window. Then custom "polygon cursor" is displayed. Variable ts.VTColor[0] contains the color of the cursor. When cursor position needs to be updated, it is necessary to erase the cursor drawn previously and restore the background color that was previously backed up in ts.VTColor[1]. <br>
While drawing polygon cursor in a position that already contains a character, this character will be overwritten. Therefore, it is necessary to re-drawing the character. This can be done by using UpdateCaretKillFocus() function. This function sends WM_PAINT message and triggers InvalidateRect(), which then redraws the character. <br>

<pre class=code>
void CaretKillFocus(BOOL show)
{
  int CaretX, CaretY;
  POINT p[5];
  HPEN oldpen;
  HDC hdc;

  DispInitDC();
  hdc = VTDC;

  CaretX = (CursorX-WinOrgX)*FontWidth;
  CaretY = (CursorY-WinOrgY)*FontHeight;

  p[0].x = CaretX;
  p[0].y = CaretY;
  p[1].x = CaretX;
  p[1].y = CaretY + FontHeight - 1;
  if (CursorOnDBCS)
	p[2].x = CaretX + FontWidth*2 - 1;
  else
	p[2].x = CaretX + FontWidth - 1;
  p[2].y = CaretY + FontHeight - 1;
  if (CursorOnDBCS)
	p[3].x = CaretX + FontWidth*2 - 1;
  else
	p[3].x = CaretX + FontWidth - 1;
  p[3].y = CaretY;
  p[4].x = CaretX;
  p[4].y = CaretY;

  if (show) {  // Show polygon cursor (non-focused)
	  oldpen = SelectObject(hdc, CreatePen(PS_SOLID, 0, ts.VTColor[0]));
  } else {
	  oldpen = SelectObject(hdc, CreatePen(PS_SOLID, 0, ts.VTColor[1]));
  }
  Polyline(VTDC, p, 5);
  oldpen = SelectObject(hdc, oldpen);
  DeleteObject(oldpen);

  DispReleaseDC();
}
</pre>


  <h3>Handling Inactive Window Cursor States </h3>
Since inactive window cursor may be in different states, we need to properly handle cursor state changes. Below is the list of possible cases. 

<p>
<ul>
  <li>Window is active (Active == TRUE), so there is no need to draw polygon caret (CaretKillFocus).</li>
  <li>When CaretOn() is called for non-active (Active == FALSE) window, ShowCaret() has to launch polygon caret drawing function and pass it argument TRUE.</li>
  <li>When CaretOff() is called for non-active (Active == FALSE) window, ShowCaret() has to launch polygon caret drawing function and pass it argument FALSE.</li>
  <li>While retrieving caret state with IsCaretOn() function, additional condition needs to be added: OR (! Active && (CaretStatus == 0)).</li>
  <li>Call to ChangeCaret() does nothing and can be ignored.</li>
  <li>When WM_KILLFOCUS message is received while IsCaretOn() is TRUE, polygon caret drawing function has to be launched with argument TRUE.</li>
  <li>When WM_ACTIVE message is received while IsCaretOn() is TRUE, polygon caret drawing function has to be launched with argument FALSE.</li>
</ul>
</p>

<br>


<hr>


<h2><a name="serial">Serial Port</a></h2>
  <h3>Overview</h3>
Tera Term supports the UART(16550A) compatible serial port. The serial port is also called the COM(Communication Port). The COM port that is detected by the operation system are named for the "COM1", "COM2" and so on. At most 256 COM ports(COM1 - 256) can be available on the Microsoft Windows XP. <br>

The COM port of the personal computer has not more than two, recently the personal computer has no COM port. So, the USB serial converter cable is released. This product has as a feature that a user can change the number of COM port. Namely, when the two COM ports exist on the system, the Tera Term will not detect two COM ports as the "COM1" and "COM2", but the "COM1" and "COM7". <br>
 
  <h3>List up COM ports</h3>
The former Tera Term lists up all COM ports from the "COM1" to "COM256" on the connection dialog, so it is not easy to use. When the connection dialog is called, the Tera Term always scans the COM ports recognized by the operating system and lists up available COM ports. The detection logic is the DetectComPorts()#ttcmn.c file. The QueryDosDevice() API can search the "COM" from the MS-DOS device name. <br>

<pre class=code>
	if (((h = GetModuleHandle("kernel32.dll")) != NULL) &&
	    (GetProcAddress(h, "QueryDosDeviceA") != NULL) &&
	    (QueryDosDevice(NULL, devicesBuff, 65535) != 0)) {
		p = devicesBuff;
		while (*p != '\0') {
			if (strncmp(p, "COM", 3) == 0 && p[3] != '\0') {
				ComPortTable[comports++] = atoi(p+3);
				if (comports >= ComPortMax)
					break;
			}
			p += (strlen(p)+1);
		}
</pre>

  <h3>Retrieve COM port full name</h3>
Additionally, the ListupSerialPort()#ttcmn.c can retrieve the full name of every COM port. <br>
  
<pre class=code>
static void ListupSerialPort(LPWORD ComPortTable, int comports, char **ComPortDesc, int ComPortMax)
{
	GUID ClassGuid[1];
	DWORD dwRequiredSize;
	BOOL bRet;
	HDEVINFO DeviceInfoSet = NULL;
	SP_DEVINFO_DATA DeviceInfoData;
	DWORD dwMemberIndex = 0;
	int i;

	DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

	bRet =
		SetupDiClassGuidsFromName(_T("PORTS"), (LPGUID) & ClassGuid, 1,
		                          &dwRequiredSize);
	if (!bRet) {
		goto cleanup;
	}

	DeviceInfoSet =
		SetupDiGetClassDevs(&ClassGuid[0], NULL, NULL, DIGCF_PRESENT | DIGCF_PROFILE);

	if (DeviceInfoSet) {
		dwMemberIndex = 0;
		while (SetupDiEnumDeviceInfo
		       (DeviceInfoSet, dwMemberIndex++, &DeviceInfoData)) {
			TCHAR szFriendlyName[MAX_PATH];
			TCHAR szPortName[MAX_PATH];
			DWORD dwReqSize = 0;
			DWORD dwPropType;
			DWORD dwType = REG_SZ;
			HKEY hKey = NULL;

			bRet = SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
			                                        &DeviceInfoData,
			                                        SPDRP_FRIENDLYNAME,
			                                        &dwPropType,
			                                        (LPBYTE)
			                                        szFriendlyName,
			                                        sizeof(szFriendlyName),
			                                        &dwReqSize);

			hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
			                            &DeviceInfoData,
			                            DICS_FLAG_GLOBAL,
			                            0, DIREG_DEV, KEY_READ);
			if (hKey) {
				long lRet;
				dwReqSize = sizeof(szPortName);
				lRet = RegQueryValueEx(hKey,
				                       _T("PortName"),
				                       0,
				                       &dwType,
				                       (LPBYTE) & szPortName,
				                       &dwReqSize);
				RegCloseKey(hKey);
			}

			if (_strnicmp(szPortName, "COM", 3) == 0) {  // Found COM port driver
				int port = atoi(&szPortName[3]);
				int i;

				for (i = 0 ; i < comports ; i++) {
					if (ComPortTable[i] == port) {  // Confirm COM connection
						ComPortDesc[i] = _strdup(szFriendlyName);
						break;
					}
				}
			}
		}
	}

cleanup:
	SetupDiDestroyDeviceInfoList(DeviceInfoSet);
}
</pre>


<hr>


<h2><a name="xyzmodem">Binary Transfer Protocols</a></h2>
  <h3>Overview</h3>
  Creation of personal computers triggered development of communication protocols that would allow to send binary files from one computer to another. Many different protocols were born at that time and most of them have become legacy by now. One of the areas where such protocols are still in demand is communication with embedded devices for uploading or retrieving firmware. Tera Term supports 3 such protocols XMODEM, YMODEM and ZMODEM, which are described in this section. <br>
 

  <h3>Specification</h3>
  XMODEM protocol is rather old, it is in use since 1977. XMODEM was developed by Ward Christensen, had simple specifications and was easy to implement. Numerous improvements made to XMODEM protocol during the first years of its existence were consolidated by Chuck Forsberg and the result of this work was called YMODEM protocol. Chuck Forsberg did not stop there and kept improving YMODEM protocol that eventually brought to life ZMODEM protocol. This was happened in 1986. <br>
XMODEM, YMODEM and ZMODEM protocols were so popular that their support was added to almost every communication program developed at that time. Tera Term supports basic XMODEM / YMODEM / ZMODEM functionality. Depending on peer node implementation certain functions may not work correctly, or fine tuning of configuration may be required. <br>

  <h3>Hierarchical Structure</h3>
  In order to simplify binary transfer protocol implementation, hierarchical structure of modules is created.

<pre class=code>
      +-------------------------------------------------------+
      |ttermpro.exe (filesys.cpp)                             |
      +-------------------------------------------------------+
      |ttpfile.dll (ttfile.c)                                 |
      +-------+--------+--------+--------+--------+-----------+
      |Kermit | XMODEM | YMODEM | ZMODEM | B-Plus | Quick-VAN |
      +-------+--------+--------+--------+--------+-----------+
</pre>

For example, if you select to send a file via XMODEM, the process flow will be as follows.

<pre class=code>
filesys.cpp: OnFileXSend() -> XMODEMStart() -> OpenProtoDlg() ->
ttfile.c: ProtoInit() ->
xmodem.c: XInit()
</pre>

The processing of received file using ZMODEM is as follows.

<pre class=code>
filesys.cpp: OnFileZRcv() -> ZMODEMStart() -> OpenProtoDlg() ->
ttfile.c: ProtoInit() ->
zmodem.c: ZInit()
</pre>

  <h3>Entry Points</h3>
  To simplify new protocol implementation all interface functions (entry points) are placed into ttpfile.dll file. Entry points are called ProtoInit(), ProtoParse(), ProtoTimeOutProc() and ProtoCancel(). <br>
  Entry points of XMODEM are shown below.
 

<table border=1 align=center>
<tr>
  <th>Function</th>
  <th>Meaning</th>
</tr>

<tr>
  <td>XInit</td>
  <td>Initialization</td>
</tr>

<tr>
  <td>XSendPacket</td>
  <td>File transmission</td>
</tr>

<tr>
  <td>YReadPacket</td>
  <td>File reception</td>
</tr>

<tr>
  <td>XTimeOutProc</td>
  <td>Timeout handling</td>
</tr>

<tr>
  <td>XCancel</td>
  <td>Cancellation</td>
</tr>
</table>
<br>

Entry points of ZMODEM are shown below.

<table border=1 align=center>
<tr>
  <th>Function</th>
  <th>Meaning</th>
</tr>

<tr>
  <td>ZInit</td>
  <td>Initialization</td>
</tr>

<tr>
  <td>ZParse</td>
  <td>File transmission</td>
</tr>

<tr>
  <td>ZParse</td>
  <td>File reception</td>
</tr>

<tr>
  <td>ZTimeOutProc</td>
  <td>Timeout handling</td>
</tr>

<tr>
  <td>ZCancel</td>
  <td>Cancellation</td>
</tr>
</table>

  <h3>Testing Connectivity</h3>
  Binary transfer protocols are usually used with serial connections. Modern PC-s are rarely equipped with serial ports, which makes testing of these protocols more challenging. One on the options is to use Null-modem emulator like <a href="http://com0com.sourceforge.net/">com0com</a>. It will generate two virtual COM ports on a single PC. Then we can use 2 instances of Tera Term to connect these virtual serial ports, or use Tera Term and another software terminal emulator for this purpose. 

<div align="center">
<img src="image/devman_com0com.png" width=468 height=171>
</div>


  <h3>Characters</h3>
  Binary transfer protocol uses character notation such as ACK or CAN, which originates from 7-bit ASCII table. You can refer ASCII table by using man 7 ascii. Most frequently used characters are listed below.
  

<pre class=code>
Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
------------------------------------------------------------------------
001   1     01    SOH (start of heading)      101   65    41    A
002   2     02    STX (start of text)         102   66    42    B
004   4     04    EOT (end of transmission)   104   68    44    D
006   6     06    ACK (acknowledge)           106   70    46    F
025   21    15    NAK (negative ack.)         125   85    55    U
030   24    18    CAN (cancel)                130   88    58    X
</pre>



  <h3>XMODEM</h3>
  XMODEM divides the data files into blocks with predetermined size (128 bytes or 1,024 bytes) and expects ACK after sending each block. At low transmission speeds implementing a mechanism of sending/receiving ACK-s after every single block is not difficult. <br>

If the data is shorter than predetermined block size, it will be padded with CPMEOF (0x1A). In other words, when you send a file, the size of transmitted data is always equal to a multiple of predetermined block size. Therefore, if integrity of transmited file has to be determined, XMOMDEM won't be able to do that. It should be noted that term CPMEOF is related to MS-DOS operating system. Its predecessor - CP/M called this character EOF which meant end of text file. <br>

More information about XMODEM protocol can be found on Wikipedia.

<ul>
  <li><a href="https://en.wikipedia.org/wiki/XMODEM">XMODEM - Wikipedia</a></li>
</ul>
<br>

If "XmodemLog" entry of teraterm.ini file is set to "On", Tera Term will log communication data in "XMODEM.LOG" file. This file will be created in Tera Term installation directory.

<pre class=code>
; XMODEM log
XmodemLog=on
</pre>

Sample log file where Tera Term (COM10) sends to <a href="http://nanno.dip.jp/softlib/man/rlogin/">RLogin</a> (COM11) 67-byte long file using XMODEM protocol is shown below. <br>
"&lt;&lt;&lt;" indicates the data Tera Term received from the host, "&gt;&gt;&gt;" shows the data Tera Term sent to the host.
  
<pre class=code>
&lt;&lt;&lt;
15                                                  .

&gt;&gt;&gt;
01 01 FE 23 0D 0A 23 20 6B 6E 6F 77 6E 5F 68 6F     ...#..# known_ho
73 74 73 20 66 69 6C 65 20 66 6F 72 20 54 54 53     sts file for TTS
53 48 28 41 6E 20 53 53 48 20 45 78 74 65 6E 73     SH(An SSH Extens
69 6F 6E 20 74 6F 20 54 65 72 61 20 54 65 72 6D     ion to Tera Term
29 0D 0A 23 0D 0A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     )..#............
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A EC                                         ....

&lt;&lt;&lt;
06                                                  .

&gt;&gt;&gt;
04                                                  .

&lt;&lt;&lt;
06 
</pre>

Step by step explanation of the above log:
  
<ol>
 <li>NAK is received (15)</li>
 <li>Data block is sent</li>
 <li>ACK is received (06)</li>
 <li>EOT is sent (04)</li>
 <li>ACK is received (06)</li>
</ol>

Transmitted block contains the header (3byte) + data (128byte) + CRC (1byte). In above example data size was less than 128 bytes and the end of block was filled with CPMEOF (0x1A).

<p></p>

Now lets try to send a bigger file (1772 bytes). It will be divided in (1772 + 127) / 128 = 14 blocks. Communication log for such file transmission is shown below. <br>
The second byte of the header is a block number (starting form 1). Block number increments from 1 (0x01) to 14 (0x0E). Since the last block is shorter than 128 bytes it is padded with CPMEOF. <br>

All this is done in accordance with XMODEM protocol, however it is easy to see that padding at the end of transmitted file actually can corrupt binary file.

<pre class=code>
&lt;&lt;&lt;
15                                                  .

&gt;&gt;&gt;
01 01 FE 3B 20 73 61 6D 70 6C 65 20 6D 61 63 72     ...; sample macr
6F 20 6F 66 20 54 65 72 61 20 54 65 72 6D 0D 0A     o of Tera Term..
3B 0D 0A 3B 20 46 69 6C 65 3A 20 73 63 72 65 65     ;..; File: scree
6E 63 61 70 74 75 72 65 2E 74 74 6C 0D 0A 3B 20     ncapture.ttl..; 
44 65 73 63 72 69 70 74 69 6F 6E 3A 20 63 61 70     Description: cap
74 75 72 65 20 73 63 72 65 65 6E 20 63 6F 6E 74     ture screen cont
65 6E 74 73 20 61 6E 64 20 77 72 69 74 65 20 74     ents and write t
6F 20 66 69 6C 65 0D 0A 3B 20 45 6E 76 69 72 6F     o file..; Enviro
6E 6D 65 F4                                         nme.

&lt;&lt;&lt;
06                                                  .

&gt;&gt;&gt;
01 02 FD 6E 74 3A 20 67 65 6E 65 72 69 63 0D 0A     ...nt: generic..
3B 20 55 70 64 61 74 65 3A 20 32 30 30 37 2F 31     ; Update: 2007/1
31 2F 32 35 2C 20 31 32 2F 35 2C 20 32 30 30 38     1/25, 12/5, 2008
2F 30 31 2F 33 30 0D 0A 3B 20 41 75 74 68 6F 72     /01/30..; Author
3A 20 49 57 41 4D 4F 54 4F 20 4B 6F 75 69 63 68     : IWAMOTO Kouich
69 20 28 64 6F 64 61 29 2C 20 59 75 74 61 6B 61     i (doda), Yutaka
20 48 69 72 61 74 61 0D 0A 3B 20 54 69 70 73 3A      Hirata..; Tips:
0D 0A 3B 20 20 20 49 74 20 69 73 20 72 65 63 6F     ..;   It is reco
6D 6D 65 CA                                         mme.

&lt;&lt;&lt;
06                                                  .

&gt;&gt;&gt;
01 03 FC 6E 64 65 64 20 74 68 61 74 20 79 6F 75     ...nded that you
20 77 69 6C 6C 20 61 64 64 20 69 6E 20 74 68 65      will add in the
20 66 6F 6C 6C 6F 77 69 6E 67 20 65 6E 74 72 79      following entry
0D 0A 3B 20 20 20 69 6E 20 60 4B 45 59 42 4F 41     ..;   in `KEYBOA
52 44 2E 43 4E 46 27 20 66 69 6C 65 20 62 65 63     RD.CNF' file bec
61 75 73 65 20 79 6F 75 20 63 61 6E 20 63 61 70     ause you can cap
74 75 72 65 20 79 6F 75 72 20 73 63 72 65 65 6E     ture your screen
0D 0A 3B 20 20 20 61 74 20 6F 6E 65 27 73 20 66     ..;   at one's f
69 6E 67 9C                                         ing.

                    :
                    :
                    :

&lt;&lt;&lt;
06                                                  .

&gt;&gt;&gt;
01 0E F1 73 70 72 69 6E 74 66 20 22 73 63 72 65     ...sprintf &quot;scre
65 6E 63 61 70 74 75 72 65 5F 25 73 25 73 25 73     encapture_%s%s%s
2D 25 73 25 73 25 73 2E 74 78 74 22 20 44 61 74     -%s%s%s.txt&quot; Dat
65 59 20 44 61 74 65 4D 20 44 61 74 65 44 20 54     eY DateM DateD T
69 6D 65 48 20 54 69 6D 65 4D 20 54 69 6D 65 53     imeH TimeM TimeS
0D 0A 66 69 6C 65 6E 61 6D 65 20 3D 20 69 6E 70     ..filename = inp
75 74 73 74 72 0D 0A 72 65 74 75 72 6E 0D 0A 1A     utstr..return...
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 75                                         ...u

&lt;&lt;&lt;
06                                                  .

&gt;&gt;&gt;
04                                                  .

&lt;&lt;&lt;
06 
</pre>


  <h3>YMODEM</h3>
  YMODEM is more advanced version of XMODEM protocol. Unlike XMODEM, YMODEM can send file name and file size to the host. Knowing file size allows the host to remove CPMEOF characters from the end of transmitted file and avoid possible file corruption. <br>
 
More information about YMODEM protocol can be found on Wikipedia.

<ul>
  <li><a href="http://en.wikipedia.org/wiki/YMODEM">YMODEM - Wikipedia</a></li>
</ul>
<br>

If "YmodemLog" entry of teraterm.ini file is set to "On", Tera Term will log communication data in "YMODEM.LOG" file. This file will be created in Tera Term installation directory.

<pre class=code>
; YMODEM log
YmodemLog=on
</pre>

Sample log file where Tera Term (COM10) sends to <a href="http://nanno.dip.jp/softlib/man/rlogin/">RLogin</a> (COM11) 67-byte long file using YMODEM protocol is shown below. <br>
"&lt;&lt;&lt;" indicates the data Tera Term received from the host, "&gt;&gt;&gt;" shows the data Tera Term sent to the host.
  
<pre class=code>
&lt;&lt;&lt;
43                                                  C

&gt;&gt;&gt;
02 00 FF 73 73 68 5F 6B 6E 6F 77 6E 5F 68 6F 73     ...ssh_known_hos
74 73 00 36 37 20 31 31 31 36 32 32 30 30 31 30     ts.67 1116220010
30 20 31 30 30 36 34 34 00 00 00 00 00 00 00 00     0 100644........
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 1B 08                                      .....

&lt;&lt;&lt;
06 43                                               .C

&gt;&gt;&gt;
02 01 FE 23 0D 0A 23 20 6B 6E 6F 77 6E 5F 68 6F     ...#..# known_ho
73 74 73 20 66 69 6C 65 20 66 6F 72 20 54 54 53     sts file for TTS
53 48 28 41 6E 20 53 53 48 20 45 78 74 65 6E 73     SH(An SSH Extens
69 6F 6E 20 74 6F 20 54 65 72 61 20 54 65 72 6D     ion to Tera Term
29 0D 0A 23 0D 0A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     )..#............
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A 1A     ................
1A 1A 1A 6D 7A                                      ...mz

&lt;&lt;&lt;
06                                                  .

&gt;&gt;&gt;
04                                                  .

&lt;&lt;&lt;
06 43                                               .C

&gt;&gt;&gt;
02 00 FF 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
00 00 00 00 00                                      .....

&lt;&lt;&lt;
06 
</pre>

Step by step explanation of the above log:
  
<ol>
 <li>'C' request to send (43)</li>
 <li>Block 0 is sent (file information)</li>
 <li>ACK is received (06)</li>
 <li>'C' request to send (43)</li>
 <li>Block 1 is sent (file information)</li>
 <li>ACK is received (06)</li>
 <li>EOT is sent (04)</li>
 <li>ACK is received (06)</li>
 <li>'C' request to send (43)</li>
 <li>Block 0 is sent (all zeros)</li>
 <li>ACK is received (06)</li>
</ol>



  <h3>ZMODEM</h3>

TBD



  <h3>KERMIT</h3>
KERMIT (Kermit: Frog Muppet from Sesame Street) is a file transfer protocol developed in Columbia University in 1981. It is currently maintained by Kermit project. Specification is available from the following site. <br>  
  
  More information about KERMIT project can be found on KERMIT project website. 

<ul>
  <li><a href="http://www.kermitproject.org/">The Kermit Project</a></li>
</ul>
<br>

This site distributes KERMIT source code variations for different platforms. The are called C-Kermit, E-Kermit and Kermit95. <br>

If "KmtLog" entry of teraterm.ini file is set to "On", Tera Term will log communication data in "KERMIT.LOG" file. This file will be created in Tera Term installation directory.
  
<pre class=code>
; Kermit log
KmtLog=on
</pre>

KERMIT was initially designed for low speed connections that's why it could not send more than 94 bytes of data at a time. However, it now has extended option allowing to transmit several kilobytes of data if both - server and client can support this functionality. <br>

KERMIT has 2 packet formats - basic and extended. They are described in "Appendix 1. Packet Format and Types" of KERMIT specification. Below are the extracts from KERMIT specification. <br>
Basic KERMIT packet format supporting 94 byte blocks is shown below.

<pre class=code>
Basic Kermit Packet Layout
       |&lt;------Included in CHECK------&gt;|
       |                               |
+------+-----+-----+------+------ - - -+-------+
| MARK | LEN | SEQ | TYPE | DATA       | CHECK |&lt;terminator&gt;
+------+-----+-----+------+------ - - -+-------+
             |                                 |
             |&lt;--------LEN-32 characters------&gt;|

  MARK   A real control character, usually Ctrl-A (0x01).
  LEN    One character, length of remainder of packet + 32, max 95. "LEN+2" is whole size.
  SEQ    One character, packet sequence number + 32, modulo 64. The number is from 0 to 63.
  TYPE   One character, an uppercase letter.
  DATA   Transmitted data
  CHECK  One, two or three bytes as negotiated.
  &lt;terminator&gt;  Any control character required for reading the packet.
</pre>

Extended packet format is shown below.

<pre class=code>
Kermit Extended Packet Layout
       |&lt;-------------------------Included in CHECK-------------&gt;|
       |                                                         |
       |&lt;-------Included in HCHECK-------&gt;|                      |
       |                                  |                      |
+------+-----+-----+------+-------+-------+--------+----- - - - -+-------+
| MARK |     | SEQ | TYPE | LENX1 | LENX2 | HCHECK | DATA        | CHECK |
+------+-----+-----+------+-------+-------+--------+----- - - - -+-------+
        blank                                      |                     |
                                                   |&lt;-------------------&gt;|
                    LX1=LENX1-32, LX2=LX2-32 95 x LX1 + LX2 chars
HCHECK is a single-character type 1 checksum
</pre>

In order to send more than 94 bytes of data, extended format's field containing data size is increased to two bytes. "LEN" is always zero of basic format (after adding 32 it is equal to ASCII code of whitespace character). Additionally, the size of the header increased by 3 bytes and haeder checksum was added. <br>
  <br>
  
  Initialization String
  
<pre class=code>
Initialization String
1         2      3       4       5       6       7       8       9       10
+-------+-------+-------+-------+-------+-------+-------+-------+-------+- -
| MAXL  | TIME  | NPAD  | PADC  | EOL   | QCTL  | QBIN  | CHKT  | REPT  |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+- -
     10           CAPAS+1  CAPAS+2  CAPAS+3
- --+-------+ - -+--------+--------+--------+- -
    | CAPAS ... 0| WINDO  | MAXLX1 | MAXLX1 |
- --+-------+-  -+--------+--------+--------+- -

MAXL  Maximum length (0-94) +32
TIME  Timeout, seconds (0-94) +32
NPAD  Number of pad characters (0-94) +32
EOL   Packet terminator (0-63) +32
QCTL  Control prefix, literal
QBIN  8th bit prefix, literal
CHKT  Block check type {1,2,3}, literal
REPT  Repeat count prefix, literal
CAPAS Extendable capabilities mask, ends when value-32 is even
WINDO Window size (0-31) +32
MAXLX1
      High part of extended packet maximum length (int(max/95)+32)
MAXLX2
      Low part of extended packet maximum length (mod(max,95)+32)
</pre>

Below is the list of packet types.

<pre class=code>
Packet Types
Y   Acknowledgment (ACK). Data according to what kind of packet is being acknowledged.
N   Negative Acknowledgment (NAK). Data field always empty.
S   Send Initiation. Data field contains unencoded initialization string. Tells receiver to expect files. ACK to this packet also contains unencoded initialization string.
I   Initialize. Data field contains unencoded initialization string. Sent to server to set parameters prior to a command. ACK to this packet also contains unencoded initialization string.
F   File Header. Indicates file data about to arrive for named file. Data field contains encoded file name. ACK to this packet may contain encoded name receiver will store file under.
X   Text Header. Indicates screen data about to arrive. Data field contains encoded heading for display.
A   File Attributes. Data field contains unencoded attributes. ACK may contain unencoded corresponding
agreement or refusal, per attribute.
D   Data Packet. Data field contains encoded file or screen data. ACK may contain X to interrupt sending this file, Z to interrupt entire transaction.
Z   End of file. Data field may contain D for Discard.
B   Break transmission.
E   Error. Data field contains encoded error message.
R   Receive Initiate. Data field contains encoded file name.
C   Host Command. Data field contains encoded command for host’s command processor.
K   Kermit Command. Data field contains encoded command for Kermit command processor.
T   Timeout psuedopacket, for internal use.
Q   Block check error psuedopacket, for internal use.
G   Generic Kermit Command. Data field contains a single character subcommand, followed by zero or more
    length-encoded operands, encoded after formation:
    I Login [&lt;%user[%password[%account]]&gt;]
    C CWD, Change Working Directory [&lt;%directory[%password]&gt;]
    L Logout, Bye
    F Finish (Shut down the server, but don’t logout).
    D Directory [&lt;%filespec&gt;]
    U Disk Usage Query [&lt;%area&gt;]
    E Erase (delete) &lt;%filespec&gt;
    T Type &lt;%filespec&gt;
    R Rename &lt;%oldname%newname&gt;
    K Copy &lt;%source%destination&gt;
    W Who’s logged in? [&lt;%user ID or network host[%options]&gt;]
    M Send a short Message &lt;%destination%text&gt;
    H Help [&lt;%topic&gt;]
    Q Server Status Query
    P Program &lt;%[program-filespec][%program-commands]&gt;
    J Journal &lt;%command[%argument]&gt;
    V Variable &lt;%command[%argument[%argument]]&gt;
</pre>


</BODY>
</HTML>
